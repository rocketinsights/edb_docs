---
title: Introduction
navTitle: EDB Postgres Advanced Server
---


This guide describes the features of EDB Postgres Advanced Server (Advanced Server)*.*

Advanced Server adds extended functionality to the open-source PostgreSQL database. The extended functionality supports database administration, enhanced SQL capabilities, database and application security, performance monitoring and analysis, and application development utilities. This guide documents those features that are exclusive to Advanced Server:
 - **Database Administration.** Section 2 contains information about features related to database administration.

> *Configuration parameters* described in Section <span class="underline">2.1</span> control the basic characteristics and performance of an Advanced Server instance.
>
> *Audit logging* described in Section <span class="underline">2.2</span> provides enhanced database auditing capabilities.
>
> *Unicode Collation Algorithm* described in Section <span class="underline">2.3</span> provides the capability to create a collation specific to your particular needs on a UTF-8 encoded database.
 - **Security.** Section 3 contains information about security features supported by Advanced Server.

> *SQL/Protect* described in Section <span class="underline">3.1</span> provides protection against SQL injection attacks.
>
> *Virtual Private Database* described in Section <span class="underline">3.2</span> provides fine-grained, row level access.
 - **EDB Resource Manager.** Section 4 contains information about the EDB Resource Manager feature, which provides the capability to control system resource usage by Advanced Server processes.

> *Resource Groups* described in Section <span class="underline">4.1</span> shows how to create and maintain the groups on which resource limits can be defined and to which Advanced Server processes can be assigned.
>
> *CPU Usage Throttling* described in Section <span class="underline">4.2</span> provides a method to control CPU usage by Advanced Server processes.
>
> *Dirty Buffer Throttling* described in Section <span class="underline">4.3</span> provides a method to control the dirty rate of shared buffers by Advanced Server processes.
 - **The libpq C Library.** The *libpq C library* described in Section <span class="underline">5</span> is the C application programming interface (API) language for Advanced Server.

<!-- end list -->
 - > **The PL Debugger.** *The PL Debugger* described in Section <span class="underline">6</span> is a graphically oriented debugging tool for PL/pgSQL.

<!-- end list -->
 - **Performance Analysis and Tuning.** Section <span class="underline">7</span> contains the various tools for analyzing and improving application and database server performance.

> *Dynatune* described in Section <span class="underline">7.1</span> provides a quick and easy means for configuring Advanced Server depending upon the type of application usage.
>
> *Infinite Cache* described in Section <span class="underline">7.2</span> provides for performance improvement using memory caching. **Note:** Infinite Cache has been deprecated and may be removed in a future release. Please contact your EnterpriseDB Account Manager or [mailto:sales@enterprisedb.com](mailto:sales@enterprisedb.com) for more information.
>
> *Index Advisor* described in Section <span class="underline">7.3</span> helps to determine the additional indexes needed on tables to improve application performance.
>
> *SQL Profiler* described in Section <span class="underline">7.4</span> locates and diagnoses poorly running SQL queries in applications.
 - **Compatibility Features.** Section <span class="underline">8</span> provides an introduction to some of the features that provide compatibility with Oracle databasese. For more information about compatibility features, see the [*Database Compatibility for Oracle Developer's Guide*](http://www.enterprisedb.com/docs/en/9.5/oracompat/toc.html).
 - **System Catalog Tables.** Section <span class="underline">10</span> contains additional *system catalog tables* added for Advanced Server specific database objects.
 - **Advanced Server Keywords.** Section <span class="underline">11</span> contains information about the words that Advanced Server recognizes as keywords.

For information about the features that are shared by Advanced Server and PostgreSQL, see the PostgreSQL core documentation, available at:

[http://www.postgresql.org/docs/9.6/static/index.html](http://www.postgresql.org/docs/9.5/static/index.html)

## What’s New

The following features have been added to EDB Postgres Advanced Server 9.5 to create Advanced Server 9.6:
 - Advanced Server now includes an extension that you can use to filter audit log entries. For more information about the edb\_filter\_log.errcode configuration parameter, see Section <span class="underline">2.2.2</span>.

## Typographical Conventions Used in this Guide

Certain typographical conventions are used in this manual to clarify the meaning and usage of various commands, statements, programs, examples, etc. This section provides a summary of these conventions.

In the following descriptions a *term* refers to any word or group of words that may be language keywords, user-supplied values, literals, etc. A term’s exact meaning depends upon the context in which it is used.
 - *Italic font* introduces a new term, typically, in the sentence that defines it for the first time.
 - Fixed-width (mono-spaced) font is used for terms that must be given literally such as SQL commands, specific table and column names used in the examples, programming language keywords, directory paths and file names, parameter values, etc. For example postgresql.conf, SELECT \* FROM emp;
 - *Italic fixed-width font* is used for terms for which the user must substitute values in actual usage. For example, DELETE FROM *table\_name*;
 - A vertical pipe | denotes a choice between the terms on either side of the pipe. A vertical pipe is used to separate two or more alternative terms within square brackets (optional choices) or braces (one mandatory choice).
 - Square brackets \[ \] denote that one or none of the enclosed term(s) may be substituted. For example, \[ a | b \], means choose one of “a” or “b” or neither of the two.
 - Braces {} denote that exactly one of the enclosed alternatives must be specified. For example, { a | b }, means exactly one of “a” or “b” must be specified.
 - Ellipses ... denote that the proceeding term may be repeated. For example, \[ a | b \] ... means that you may have the sequence, “b a a b a”.

## Other Conventions Used in this Guide

This guide applies to both Linux and Windows systems. Directory paths are presented in the Linux format with forward slashes. When working on Windows systems, start the directory path with the drive letter followed by a colon and substitute back slashes for forward slashes.

For Linux installations, the default installation directory path is

> /opt/edb/as9.6

For Windows installations, the default installation directory path is

> C:\\Program Files\\edb\\as9.6

## About the Examples Used in this Guide

The examples in this guide are shown in the type and background illustrated below.

Examples and output from examples are shown in fixed-width, blue font on a light blue background.

The examples use the sample tables, dept, emp, and jobhist, created and loaded when Advanced Server is installed.

The tables and programs in the sample database can be re-created at any time by executing the following script:

> opt/edb/as9.6/installer/server/edb-sample.sql.

The script:
 - Creates the sample tables and programs in the currently connected database.
 - Grants all permissions on the tables to the PUBLIC group.

The tables and programs will be created in the first schema of the search path in which the current user has permission to create tables and procedures. You can display the search path by issuing the command:

SHOW SEARCH\_PATH;

You can use PSQL commands to modify the search path.

#### Sample Database Description

The sample database represents employees in an organization. It contains three types of records: employees, departments, and historical records of employees.

Each employee has an identification number, name, hire date, salary, and manager. Some employees earn a commission in addition to their salary. All employee-related information is stored in the emp table.

The sample company is regionally diverse, so it tracks the locations of its departments. Each company employee is assigned to a department. Each department is identified by a unique department number and a short name. Each department is associated with one location. All department-related information is stored in the dept table.

The company also tracks information about jobs held by the employees. Some employees have been with the company for a long time and have held different positions, received raises, switched departments, etc. When a change in employee status occurs, the company records the end date of the former position. A new job record is added with the start date and the new job title, department, salary, and the reason for the status change. All employee history is maintained in the jobhist table.

The following is the pg-sample.sql script:

SET datestyle TO 'iso, dmy';

\--

\-- Script that creates the 'sample' tables, views

\-- functions, triggers, etc.

\--

\-- Start new transaction - commit all or nothing

\--

BEGIN;

\--

\-- Create and load tables used in the documentation examples.

\--

\-- Create the 'dept' table

\--

CREATE TABLE dept (

deptno NUMERIC(2) NOT NULL CONSTRAINT dept\_pk PRIMARY KEY,

dname VARCHAR(14) CONSTRAINT dept\_dname\_uq UNIQUE,

loc VARCHAR(13)

);

\--

\-- Create the 'emp' table

\--

CREATE TABLE emp (

empno NUMERIC(4) NOT NULL CONSTRAINT emp\_pk PRIMARY KEY,

ename VARCHAR(10),

job VARCHAR(9),

mgr NUMERIC(4),

hiredate DATE,

sal NUMERIC(7,2) CONSTRAINT emp\_sal\_ck CHECK (sal \> 0),

comm NUMERIC(7,2),

deptno NUMERIC(2) CONSTRAINT emp\_ref\_dept\_fk

REFERENCES dept(deptno)

);

\--

\-- Create the 'jobhist' table

\--

CREATE TABLE jobhist (

empno NUMERIC(4) NOT NULL,

startdate TIMESTAMP(0) NOT NULL,

enddate TIMESTAMP(0),

job VARCHAR(9),

sal NUMERIC(7,2),

comm NUMERIC(7,2),

deptno NUMERIC(2),

chgdesc VARCHAR(80),

CONSTRAINT jobhist\_pk PRIMARY KEY (empno, startdate),

CONSTRAINT jobhist\_ref\_emp\_fk FOREIGN KEY (empno)

REFERENCES emp(empno) ON DELETE CASCADE,

CONSTRAINT jobhist\_ref\_dept\_fk FOREIGN KEY (deptno)

REFERENCES dept (deptno) ON DELETE SET NULL,

CONSTRAINT jobhist\_date\_chk CHECK (startdate \<= enddate)

);

\--

\-- Create the 'salesemp' view

\--

CREATE OR REPLACE VIEW salesemp AS

SELECT empno, ename, hiredate, sal, comm FROM emp WHERE job = 'SALESMAN';

\--

\-- Sequence to generate values for function 'new\_empno'.

\--

CREATE SEQUENCE next\_empno START WITH 8000 INCREMENT BY 1;

\--

\-- Issue PUBLIC grants

\--

\--GRANT ALL ON emp TO PUBLIC;

\--GRANT ALL ON dept TO PUBLIC;

\--GRANT ALL ON jobhist TO PUBLIC;

\--GRANT ALL ON salesemp TO PUBLIC;

\--GRANT ALL ON next\_empno TO PUBLIC;

\--

\-- Load the 'dept' table

\--

INSERT INTO dept VALUES (10,'ACCOUNTING','NEW YORK');

INSERT INTO dept VALUES (20,'RESEARCH','DALLAS');

INSERT INTO dept VALUES (30,'SALES','CHICAGO');

INSERT INTO dept VALUES (40,'OPERATIONS','BOSTON');

\--

\-- Load the 'emp' table

\--

INSERT INTO emp VALUES (7369,'SMITH','CLERK',7902,'17-DEC-80',800,NULL,20);

INSERT INTO emp VALUES (7499,'ALLEN','SALESMAN',7698,'20-FEB-81',1600,300,30);

INSERT INTO emp VALUES (7521,'WARD','SALESMAN',7698,'22-FEB-81',1250,500,30);

INSERT INTO emp VALUES (7566,'JONES','MANAGER',7839,'02-APR-81',2975,NULL,20);

INSERT INTO emp VALUES (7654,'MARTIN','SALESMAN',7698,'28-SEP-81',1250,1400,30);

INSERT INTO emp VALUES (7698,'BLAKE','MANAGER',7839,'01-MAY-81',2850,NULL,30);

INSERT INTO emp VALUES (7782,'CLARK','MANAGER',7839,'09-JUN-81',2450,NULL,10);

INSERT INTO emp VALUES (7788,'SCOTT','ANALYST',7566,'19-APR-87',3000,NULL,20);

INSERT INTO emp VALUES (7839,'KING','PRESIDENT',NULL,'17-NOV-81',5000,NULL,10);

INSERT INTO emp VALUES (7844,'TURNER','SALESMAN',7698,'08-SEP-81',1500,0,30);

INSERT INTO emp VALUES (7876,'ADAMS','CLERK',7788,'23-MAY-87',1100,NULL,20);

INSERT INTO emp VALUES (7900,'JAMES','CLERK',7698,'03-DEC-81',950,NULL,30);

INSERT INTO emp VALUES (7902,'FORD','ANALYST',7566,'03-DEC-81',3000,NULL,20);

INSERT INTO emp VALUES (7934,'MILLER','CLERK',7782,'23-JAN-82',1300,NULL,10);

\--

\-- Load the 'jobhist' table

\--

INSERT INTO jobhist VALUES (7369,'17-DEC-80',NULL,'CLERK',800,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7499,'20-FEB-81',NULL,'SALESMAN',1600,300,30,'New Hire');

INSERT INTO jobhist VALUES (7521,'22-FEB-81',NULL,'SALESMAN',1250,500,30,'New Hire');

INSERT INTO jobhist VALUES (7566,'02-APR-81',NULL,'MANAGER',2975,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7654,'28-SEP-81',NULL,'SALESMAN',1250,1400,30,'New Hire');

INSERT INTO jobhist VALUES (7698,'01-MAY-81',NULL,'MANAGER',2850,NULL,30,'New Hire');

INSERT INTO jobhist VALUES (7782,'09-JUN-81',NULL,'MANAGER',2450,NULL,10,'New Hire');

INSERT INTO jobhist VALUES (7788,'19-APR-87','12-APR-88','CLERK',1000,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7788,'13-APR-88','04-MAY-89','CLERK',1040,NULL,20,'Raise');

INSERT INTO jobhist VALUES (7788,'05-MAY-90',NULL,'ANALYST',3000,NULL,20,'Promoted to Analyst');

INSERT INTO jobhist VALUES (7839,'17-NOV-81',NULL,'PRESIDENT',5000,NULL,10,'New Hire');

INSERT INTO jobhist VALUES (7844,'08-SEP-81',NULL,'SALESMAN',1500,0,30,'New Hire');

INSERT INTO jobhist VALUES (7876,'23-MAY-87',NULL,'CLERK',1100,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7900,'03-DEC-81','14-JAN-83','CLERK',950,NULL,10,'New Hire');

INSERT INTO jobhist VALUES (7900,'15-JAN-83',NULL,'CLERK',950,NULL,30,'Changed to Dept 30');

INSERT INTO jobhist VALUES (7902,'03-DEC-81',NULL,'ANALYST',3000,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7934,'23-JAN-82',NULL,'CLERK',1300,NULL,10,'New Hire');

\--

\-- Populate statistics table and view (pg\_statistic/pg\_stats)

\--

ANALYZE dept;

ANALYZE emp;

ANALYZE jobhist;

\--

\-- Function that lists all employees' numbers and names

\-- from the 'emp' table using a cursor.

\--

CREATE OR REPLACE FUNCTION list\_emp() RETURNS VOID

AS $$

DECLARE

v\_empno NUMERIC(4);

v\_ename VARCHAR(10);

emp\_cur CURSOR FOR

SELECT empno, ename FROM emp ORDER BY empno;

BEGIN

OPEN emp\_cur;

RAISE INFO 'EMPNO ENAME';

RAISE INFO '----- -------';

LOOP

FETCH emp\_cur INTO v\_empno, v\_ename;

EXIT WHEN NOT FOUND;

RAISE INFO '% %', v\_empno, v\_ename;

END LOOP;

CLOSE emp\_cur;

RETURN;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function that selects an employee row given the employee

\-- number and displays certain columns.

\--

CREATE OR REPLACE FUNCTION select\_emp (

p\_empno NUMERIC

) RETURNS VOID

AS $$

DECLARE

v\_ename emp.ename%TYPE;

v\_hiredate emp.hiredate%TYPE;

v\_sal emp.sal%TYPE;

v\_comm emp.comm%TYPE;

v\_dname dept.dname%TYPE;

v\_disp\_date VARCHAR(10);

BEGIN

SELECT INTO

v\_ename, v\_hiredate, v\_sal, v\_comm, v\_dname

ename, hiredate, sal, COALESCE(comm, 0), dname

FROM emp e, dept d

WHERE empno = p\_empno

AND e.deptno = d.deptno;

IF NOT FOUND THEN

RAISE INFO 'Employee % not found', p\_empno;

RETURN;

END IF;

v\_disp\_date := TO\_CHAR(v\_hiredate, 'MM/DD/YYYY');

RAISE INFO 'Number : %', p\_empno;

RAISE INFO 'Name : %', v\_ename;

RAISE INFO 'Hire Date : %', v\_disp\_date;

RAISE INFO 'Salary : %', v\_sal;

RAISE INFO 'Commission: %', v\_comm;

RAISE INFO 'Department: %', v\_dname;

RETURN;

EXCEPTION

WHEN OTHERS THEN

RAISE INFO 'The following is SQLERRM : %', SQLERRM;

RAISE INFO 'The following is SQLSTATE: %', SQLSTATE;

RETURN;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- A RECORD type used to format the return value of

\-- function, 'emp\_query'.

\--

CREATE TYPE emp\_query\_type AS (

empno NUMERIC,

ename VARCHAR(10),

job VARCHAR(9),

hiredate DATE,

sal NUMERIC

);

\--

\-- Function that queries the 'emp' table based on

\-- department number and employee number or name. Returns

\-- employee number and name as INOUT parameters and job,

\-- hire date, and salary as OUT parameters. These are

\-- returned in the form of a record defined by

\-- RECORD type, 'emp\_query\_type'.

\--

CREATE OR REPLACE FUNCTION emp\_query (

IN p\_deptno NUMERIC,

INOUT p\_empno NUMERIC,

INOUT p\_ename VARCHAR,

OUT p\_job VARCHAR,

OUT p\_hiredate DATE,

OUT p\_sal NUMERIC

)

AS $$

BEGIN

SELECT INTO

p\_empno, p\_ename, p\_job, p\_hiredate, p\_sal

empno, ename, job, hiredate, sal

FROM emp

WHERE deptno = p\_deptno

AND (empno = p\_empno

OR ename = UPPER(p\_ename));

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function to call 'emp\_query\_caller' with IN and INOUT

\-- parameters. Displays the results received from INOUT and

\-- OUT parameters.

\--

CREATE OR REPLACE FUNCTION emp\_query\_caller() RETURNS VOID

AS $$

DECLARE

v\_deptno NUMERIC;

v\_empno NUMERIC;

v\_ename VARCHAR;

v\_rows INTEGER;

r\_emp\_query EMP\_QUERY\_TYPE;

BEGIN

v\_deptno := 30;

v\_empno := 0;

v\_ename := 'Martin';

r\_emp\_query := emp\_query(v\_deptno, v\_empno, v\_ename);

RAISE INFO 'Department : %', v\_deptno;

RAISE INFO 'Employee No: %', (r\_emp\_query).empno;

RAISE INFO 'Name : %', (r\_emp\_query).ename;

RAISE INFO 'Job : %', (r\_emp\_query).job;

RAISE INFO 'Hire Date : %', (r\_emp\_query).hiredate;

RAISE INFO 'Salary : %', (r\_emp\_query).sal;

RETURN;

EXCEPTION

WHEN OTHERS THEN

RAISE INFO 'The following is SQLERRM : %', SQLERRM;

RAISE INFO 'The following is SQLSTATE: %', SQLSTATE;

RETURN;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function to compute yearly compensation based on semimonthly

\-- salary.

\--

CREATE OR REPLACE FUNCTION emp\_comp (

p\_sal NUMERIC,

p\_comm NUMERIC

) RETURNS NUMERIC

AS $$

BEGIN

RETURN (p\_sal + COALESCE(p\_comm, 0)) \* 24;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function that gets the next number from sequence, 'next\_empno',

\-- and ensures it is not already in use as an employee number.

\--

CREATE OR REPLACE FUNCTION new\_empno() RETURNS INTEGER

AS $$

DECLARE

v\_cnt INTEGER := 1;

v\_new\_empno INTEGER;

BEGIN

WHILE v\_cnt \> 0 LOOP

SELECT INTO v\_new\_empno nextval('next\_empno');

SELECT INTO v\_cnt COUNT(\*) FROM emp WHERE empno = v\_new\_empno;

END LOOP;

RETURN v\_new\_empno;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function that adds a new clerk to table 'emp'.

\--

CREATE OR REPLACE FUNCTION hire\_clerk (

p\_ename VARCHAR,

p\_deptno NUMERIC

) RETURNS NUMERIC

AS $$

DECLARE

v\_empno NUMERIC(4);

v\_ename VARCHAR(10);

v\_job VARCHAR(9);

v\_mgr NUMERIC(4);

v\_hiredate DATE;

v\_sal NUMERIC(7,2);

v\_comm NUMERIC(7,2);

v\_deptno NUMERIC(2);

BEGIN

v\_empno := new\_empno();

INSERT INTO emp VALUES (v\_empno, p\_ename, 'CLERK', 7782,

CURRENT\_DATE, 950.00, NULL, p\_deptno);

SELECT INTO

v\_empno, v\_ename, v\_job, v\_mgr, v\_hiredate, v\_sal, v\_comm, v\_deptno

empno, ename, job, mgr, hiredate, sal, comm, deptno

FROM emp WHERE empno = v\_empno;

RAISE INFO 'Department : %', v\_deptno;

RAISE INFO 'Employee No: %', v\_empno;

RAISE INFO 'Name : %', v\_ename;

RAISE INFO 'Job : %', v\_job;

RAISE INFO 'Manager : %', v\_mgr;

RAISE INFO 'Hire Date : %', v\_hiredate;

RAISE INFO 'Salary : %', v\_sal;

RAISE INFO 'Commission : %', v\_comm;

RETURN v\_empno;

EXCEPTION

WHEN OTHERS THEN

RAISE INFO 'The following is SQLERRM : %', SQLERRM;

RAISE INFO 'The following is SQLSTATE: %', SQLSTATE;

RETURN -1;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function that adds a new salesman to table 'emp'.

\--

CREATE OR REPLACE FUNCTION hire\_salesman (

p\_ename VARCHAR,

p\_sal NUMERIC,

p\_comm NUMERIC

) RETURNS NUMERIC

AS $$

DECLARE

v\_empno NUMERIC(4);

v\_ename VARCHAR(10);

v\_job VARCHAR(9);

v\_mgr NUMERIC(4);

v\_hiredate DATE;

v\_sal NUMERIC(7,2);

v\_comm NUMERIC(7,2);

v\_deptno NUMERIC(2);

BEGIN

v\_empno := new\_empno();

INSERT INTO emp VALUES (v\_empno, p\_ename, 'SALESMAN', 7698,

CURRENT\_DATE, p\_sal, p\_comm, 30);

SELECT INTO

v\_empno, v\_ename, v\_job, v\_mgr, v\_hiredate, v\_sal, v\_comm, v\_deptno

empno, ename, job, mgr, hiredate, sal, comm, deptno

FROM emp WHERE empno = v\_empno;

RAISE INFO 'Department : %', v\_deptno;

RAISE INFO 'Employee No: %', v\_empno;

RAISE INFO 'Name : %', v\_ename;

RAISE INFO 'Job : %', v\_job;

RAISE INFO 'Manager : %', v\_mgr;

RAISE INFO 'Hire Date : %', v\_hiredate;

RAISE INFO 'Salary : %', v\_sal;

RAISE INFO 'Commission : %', v\_comm;

RETURN v\_empno;

EXCEPTION

WHEN OTHERS THEN

RAISE INFO 'The following is SQLERRM : %', SQLERRM;

RAISE INFO 'The following is SQLSTATE: %', SQLSTATE;

RETURN -1;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Rule to INSERT into view 'salesemp'

\--

CREATE OR REPLACE RULE salesemp\_i AS ON INSERT TO salesemp

DO INSTEAD

INSERT INTO emp VALUES (NEW.empno, NEW.ename, 'SALESMAN', 7698,

NEW.hiredate, NEW.sal, NEW.comm, 30);

\--

\-- Rule to UPDATE view 'salesemp'

\--

CREATE OR REPLACE RULE salesemp\_u AS ON UPDATE TO salesemp

DO INSTEAD

UPDATE emp SET empno = NEW.empno,

ename = NEW.ename,

hiredate = NEW.hiredate,

sal = NEW.sal,

comm = NEW.comm

WHERE empno = OLD.empno;

\--

\-- Rule to DELETE from view 'salesemp'

\--

CREATE OR REPLACE RULE salesemp\_d AS ON DELETE TO salesemp

DO INSTEAD

DELETE FROM emp WHERE empno = OLD.empno;

\--

\-- After statement-level trigger that displays a message after

\-- an insert, update, or deletion to the 'emp' table. One message

\-- per SQL command is displayed.

\--

CREATE OR REPLACE FUNCTION user\_audit\_trig() RETURNS TRIGGER

AS $$

DECLARE

v\_action VARCHAR(24);

v\_text TEXT;

BEGIN

IF TG\_OP = 'INSERT' THEN

v\_action := ' added employee(s) on ';

ELSIF TG\_OP = 'UPDATE' THEN

v\_action := ' updated employee(s) on ';

ELSIF TG\_OP = 'DELETE' THEN

v\_action := ' deleted employee(s) on ';

END IF;

v\_text := 'User ' || USER || v\_action || CURRENT\_DATE;

RAISE INFO ' %', v\_text;

RETURN NULL;

END;

$$ LANGUAGE 'plpgsql';

CREATE TRIGGER user\_audit\_trig

AFTER INSERT OR UPDATE OR DELETE ON emp

FOR EACH STATEMENT EXECUTE PROCEDURE user\_audit\_trig();

\--

\-- Before row-level trigger that displays employee number and

\-- salary of an employee that is about to be added, updated,

\-- or deleted in the 'emp' table.

\--

CREATE OR REPLACE FUNCTION emp\_sal\_trig() RETURNS TRIGGER

AS $$

DECLARE

sal\_diff NUMERIC(7,2);

BEGIN

IF TG\_OP = 'INSERT' THEN

RAISE INFO 'Inserting employee %', NEW.empno;

RAISE INFO '..New salary: %', NEW.sal;

RETURN NEW;

END IF;

IF TG\_OP = 'UPDATE' THEN

sal\_diff := NEW.sal - OLD.sal;

RAISE INFO 'Updating employee %', OLD.empno;

RAISE INFO '..Old salary: %', OLD.sal;

RAISE INFO '..New salary: %', NEW.sal;

RAISE INFO '..Raise : %', sal\_diff;

RETURN NEW;

END IF;

IF TG\_OP = 'DELETE' THEN

RAISE INFO 'Deleting employee %', OLD.empno;

RAISE INFO '..Old salary: %', OLD.sal;

RETURN OLD;

END IF;

END;

$$ LANGUAGE 'plpgsql';

CREATE TRIGGER emp\_sal\_trig

BEFORE DELETE OR INSERT OR UPDATE ON emp

FOR EACH ROW EXECUTE PROCEDURE emp\_sal\_trig();

COMMIT;

